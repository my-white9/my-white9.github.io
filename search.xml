<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/index.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>shell语句基础篇</title>
    <url>/shell%E8%AF%AD%E5%8F%A5%E5%9F%BA%E7%A1%80%E7%AF%87/index.html</url>
    <content><![CDATA[<h1 id="课程目标："><a href="#课程目标：" class="headerlink" title="课程目标："></a>课程目标：</h1><p>熟练使用shell变量语句<br>能够编写简单的系统工具脚本<br>熟练使用awk，grep，find<br>shell介绍：<br>1.shell是解释型语言：效率低每使用一次都要进行翻译 使用解释器/bin/sh /bin/bash<br>2.sh是链接到bash无区别<br>3.对兼容性有要求会一般使用解释型语言</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>shell是人机交互的一个桥梁，负责将计算机用户的输入进行翻译来控制linux内核</p>
<h1 id="shell的种类："><a href="#shell的种类：" class="headerlink" title="shell的种类："></a>shell的种类：</h1><pre><code>[root@MissHou ~]# cat /etc/shells 
/bin/sh#是bash的一个快捷方式
/bin/bash#bash是大多数Linux默认的shell，包含的功能几乎可以涵盖shell所有的功能
/sbin/nologin#表示非交互，不能登录操作系统
/bin/dash#小巧，高效，功能相比少一些
/bin/csh#具有C语言风格的一种shell，具有许多特性，但也有一些缺陷
/bin/tcsh#是csh的增强版，完全兼容csh
常用：/bin/bash</code></pre>
<p>shell常用于编写脚本批量的处理一些问题</p>
<p>shell脚本：</p>
<h1 id="1-脚本第一行："><a href="#1-脚本第一行：" class="headerlink" title="1.脚本第一行："></a>1.脚本第一行：</h1><h2 id="！-bin-bash-使用bash解释器"><a href="#！-bin-bash-使用bash解释器" class="headerlink" title="#！/bin/bash 使用bash解释器"></a>#！/bin/bash 使用bash解释器</h2><p>注意：考虑到脚本的可移植性，因此使用/bin/env bash  env会自动的到$PATH中查找bash的可执行文件</p>
<p>!/bin/env bash和 #!/usr/bin/env bash 的区别在于 /bin只有root用户访问更加的安全</p>
<h1 id="2-脚本第二部分"><a href="#2-脚本第二部分" class="headerlink" title="2.脚本第二部分"></a>2.脚本第二部分</h1><pre><code>#!/bin/env bash
#以下是对脚本的基本信息的描述
#Name:
#Desc:
#Path:
#Usage:#用法
#Update:   #更新时间

#下面就是脚本的具体内容
commands</code></pre>
<h1 id="3-脚本第三部分：脚本具体的代码"><a href="#3-脚本第三部分：脚本具体的代码" class="headerlink" title="3.脚本第三部分：脚本具体的代码"></a>3.脚本第三部分：脚本具体的代码</h1><p>基础：编写一个脚本</p>
<pre><code>#!/bin/env bash
#Name: test
#Desc: test
#Path: /tmp/shell/test.sh
#Usage: be used to test
#Update: 2020-10-19

echo &quot;this is a test&quot;
echo &quot;hello world&quot;

[root@zabbix ~]# chmod +x /tmp/test.sh 
[root@zabbix ~]# /tmp/test.sh 
this is a test
hello world
[root@zabbix ~]# bash -x /tmp/test.sh  用于排错  指定解释器执行
+ echo &#39;this is a test&#39;
this is a test
+ echo &#39;hello world&#39;
hello world
[root@zabbix ~]# bash -n /tmp/test.sh 用于查看语法是否有错

bash /tmp/test.sh 和 sh /tmp/test.sh 都是用子shell进行
/tmp/test.sh 和 source /tmp/test.sh 是调用父shell</code></pre>
<h2 id="写一个脚本"><a href="#写一个脚本" class="headerlink" title="写一个脚本"></a>写一个脚本</h2><p>删除/tmp/目录下的所有文件</p>
<p>然后在/tmp目录里创建3个目录，分别是dir1~dir3</p>
<p>拷贝/etc/hosts文件到刚创建的dir1目录里</p>
<pre><code>#!/bin/env bash
#Name:
#Desc:
#Path:
#Update:
#Usage:

rm -rf /tmp/*
mkdir /tmp/dir&#123;1..3&#125;
cp /etc/hosts /tmp/dir1
echo &quot;finsh $(date +&#39;%F %T&#39;)&quot;</code></pre>
<h1 id="变量的定义："><a href="#变量的定义：" class="headerlink" title="变量的定义："></a>变量的定义：</h1><p>变量名区分大小写 不能有特殊符号 不可用数字开头 不可空格 驼峰命名</p>
<pre><code>A=hello
echo $(A)
hello
$&#123;A:2:4&#125;可以截取指定的
hell
unset $A 取消变量</code></pre>
<h2 id="交互式定义变量-read"><a href="#交互式定义变量-read" class="headerlink" title="交互式定义变量(read)"></a>交互式定义变量(read)</h2><pre><code>常见选项：

选项  释义
-p  定义提示用户的信息
-n  定义字符数（限制变量值的长度）
-s  不显示（不显示用户输入的内容）
-t  定义超时时间，默认单位为秒（限制用户输入变量值的超时时间）
[harry@zabbix ~]$ read -n3 &quot;input your name :&quot; name
111-bash: read: `input your name :&#39;: not a valid identifier
 read -s &quot;input your name :&quot; name
[harry@zabbix ~]$ read -p &quot;input your name :&quot; name
input your name :harry</code></pre>
<h2 id="变量来自文件"><a href="#变量来自文件" class="headerlink" title="变量来自文件"></a>变量来自文件</h2><pre><code>[harry@zabbix ~]$ read ip mask &lt; 1.txt
[harry@zabbix ~]$ echo $ip
10.0.0.1
[harry@zabbix ~]$ echo $mask
255.255.255.0
[harry@zabbix ~]$ cat 1.txt 
10.0.0.1 255.255.255.0 ##
定义有类型的变量(declare)
目的： 给变量做一些限制，固定变量的类型，比如：整型、只读</code></pre>
<h2 id="定义有类型的变量"><a href="#定义有类型的变量" class="headerlink" title="定义有类型的变量"></a>定义有类型的变量</h2><pre><code>用法：declare 选项 变量名=变量值

常用选项：

选项  释义  举例
-i  将变量看成整数 declare -i A=123
-r  定义只读变量  declare -r B=hello
-a  定义普通数组；查看普通数组   
-A  定义关联数组；查看关联数组   
-x  将变量通过环境导出   declare -x AAA=123456 等于 export AAA=123456
举例说明：

[root@MissHou ~]# declare -i A=123
[root@MissHou ~]# echo $A
123
[root@MissHou ~]# A=hello
[root@MissHou ~]# echo $A
0

[root@MissHou ~]# declare -r B=hello
[root@MissHou ~]# echo $B
hello
[root@MissHou ~]# B=world
-bash: B: readonly variable
[root@MissHou ~]# unset B
-bash: unset: B: cannot unset: readonly variable</code></pre>
<h2 id="本地变量："><a href="#本地变量：" class="headerlink" title="本地变量："></a>本地变量：</h2><pre><code>ps
ps auxf 查看所有进程   常用
-A显示所有进程（同-e）
-a显示当前终端的所有进程
-u显示进程的用户信息
-o以用户自定义形式显示进程信息
-f显示程序间的关系
echo $$ 查看当前的进程号</code></pre>
<h2 id="补充命令"><a href="#补充命令" class="headerlink" title="补充命令"></a>补充命令</h2><p>pgrep命令：以名称为依据从运行进程队列中查找进程，并显示查找到的进程id<br>选项<br>-o：仅显示找到的最小（起始）进程号;<br>-n：仅显示找到的最大（结束）进程号；<br>-l：显示进程名称；<br>-P：指定父进程号；pgrep -p 4764  查看父进程下的子进程id<br>-g：指定进程组；<br>-t：指定开启进程的终端；<br>-u：指定进程的有效用户ID。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量:"></a>全局变量:</h2><p>全局变量文件 ：全局所有的用户以及程序都能调用，默认继承<br>解读相关的配置文件</p>
<pre><code>文件名    说明    备注
~/.bashrc    当前用户的bash信息，用户登录时读取    局部。定义别名、umask、函数等
~/.bash_profile    当前用户的环境变量信息，用户登录时读取    局部。
~/.bash_logout    当前用户退出当前shell时最后读取    局部。定义用户退出时执行的程序等
~/.bash_history    当前用户的历史命令    局部。history -w保存历史记录 history -c清空历史记录
/etc/bashrc    全局的bash信息    全局。所有用户都生效
/etc/profile    全局环境变量信息    全局。系统和所有用户都生效
umask   默认0022 用于指定默认的创建文件的文件权限</code></pre>
<p>以上文件修改后需要source生效或者退出重新登陆<br>读取顺序: 环境变量:全局在用户前   bash变量：用户在全局前</p>
<pre><code>/etc/profile
$HOME /.bash_profile
$HOME /.bashrc
/etc/bashrc
$HOME/.bash_logout</code></pre>
<h2 id="环境变量："><a href="#环境变量：" class="headerlink" title="环境变量："></a>环境变量：</h2><p>环境变量:当前进程有效，且能够被子进程调用<br>env当前的环境变量 临时  直接加入<br>set当前用户的全部环境变量 临时和环境<br>export 变量名=变量值 或者 变量名=变量值；export 变量名 或者 declare -x 变量名=变量值  临时加入  放入全局配置文件中可更改永久配置</p>
<pre><code>[root@zabbix ~]# export A=hello
[root@zabbix ~]# env |grep ^A
A=hello
[root@zabbix ~]# set |grep ^A
A=hello
ABRT_DEBUG_LOG=/dev/null
[root@zabbix ~]# cat /etc/profile | grep A=hello
export A=hello</code></pre>
<h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><pre><code>内置bash中变量
系统变量(内置bash中变量) ： shell本身已经固定好了它的名字和作用.
内置变量    含义
$?    上一条命令执行后返回的状态；状态值为0表示执行正常，非0表示执行异常或错误
$0    当前执行的程序或脚本名
$#    脚本后面接的参数的个数
$*    脚本后面所有参数，参数当成一个整体输出，每一个变量参数之间以空格隔开
$@    脚本后面所有参数，参数是独立的，也是全部输出
$1~$9    脚本后面的位置参数，$1表示第1个位置参数，依次类推
$&#123;10&#125;~$&#123;n&#125;    扩展位置参数,第10个位置变量必须用&#123;&#125;大括号括起来(2位数字以上扩起来)
$$    当前所在进程的进程号，如echo $$
$！    后台运行的最后一个进程号 (当前终端）
!$    调用最后一条命令历史中的参数

[root@zabbix ~]# cat /bash.sh 
#!/bin/env bash
echo &quot;\$? = $?&quot;
echo &quot;\$0 = $0&quot;
echo &quot;\$# = $#&quot;
echo &quot;\$* = $*&quot;
echo &quot;\$@ = $@&quot;
echo &quot;\$1 = $1&quot; 
echo &quot;\$2 = $2&quot; 
echo &quot;\$3 = $3&quot; 
echo &quot;\$11 = $&#123;11&#125;&quot; 
echo &quot;\$12 = $&#123;12&#125;&quot;
echo &quot;\$$ = $$&quot;
echo &quot;\$! = $!&quot;
echo &quot;\!$ = !$&quot;
[root@zabbix ~]# sh /bash.sh  a b c d e f g h l 1 23 4 5 6 7 8
$? = 0
$0 = /bash.sh
$# = 16
$* = a b c d e f g h l 1 23 4 5 6 7 8
$@ = a b c d e f g h l 1 23 4 5 6 7 8
$1 = a
$2 = b
$3 = c
$11 = 23
$12 = 4
$$ = 14463
$! = 
\!$ = !$</code></pre>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><pre><code>表达式    举例    说明
$(( ))    echo $((1+1))    
$[ ]    echo $[10-5]    
expr    expr 10 / 5    expr程序中，数值与运算符之间需要空格隔开，乘(*)运算符需要用转义符( \ )转义，expr不能做幂运算
let    n=1;let n+=1 等价于 let n=n+1    let n=2 等价于let n=n\2，不能使用let n**=2</code></pre>
<h2 id="判断参数"><a href="#判断参数" class="headerlink" title="判断参数"></a>判断参数</h2><pre><code>    含义
-eq    相等
-ne    不等
-gt    大于
-lt    小于
-ge    大于等于
-le    小于等于</code></pre>
<h2 id="判断字符串"><a href="#判断字符串" class="headerlink" title="判断字符串"></a>判断字符串</h2><pre><code>判断参数    含义
-z    判断是否为空字符串，字符串长度为0则成立
-n    判断是否为非空字符串，字符串长度不为0则成立
string1 = string2    判断字符串是否相等
string1 != string2    判断字符串是否相不等</code></pre>
<h2 id="shell基本语句"><a href="#shell基本语句" class="headerlink" title="shell基本语句"></a>shell基本语句</h2><p> 条件判断</p>
<pre><code>if语句
判断文件类型
-e 是否存在
-d 是否是目录
-L 是否是套接字
-f 是否是普通文件
-b 是否是块文件
-S 是否是套接字文件
-c 是否是字符设备文字
-p 是否是命名管道文件
-s 是否是一个非空文件</code></pre>
<blockquote>
<p>条件判断语法格式</p>
<p>格式1： test 条件表达式</p>
<p>格式2： [ 条件表达式 ]</p>
<p>格式3： [[ 条件表达式 ]] 支持正则 =~</p>
</blockquote>
<p>判断文件新旧：修改时间<br>-nt   1是否比2新<br>-ot   1是否比2旧<br>-ef   1和2是否是同一文件</p>
<blockquote>
<p>多重条件判断<br>判断符号    含义    举例<br>-a 和 &amp;&amp;    逻辑与    [ 1 -eq 1 -a 1 -ne 0 ] [ 1 -eq 1 ] &amp;&amp; [ 1 -ne 0 ]<br>-o 和 \    \        逻辑或    [ 1 -eq 1 -o 1 -ne 1 ] [ 1 -eq 1 ] \    \    [1 -ne 1]<br>特别说明：</p>
<p>&amp;&amp; 前面的表达式为真，才会执行后面的代码</p>
<p>|| 前面的表达式为假，才会执行后面的代码</p>
<p>; 只用于分割命令或表达式</p>
</blockquote>
<pre><code>类C风格的数值比较
注意：在(( ))中，=表示赋值；==表示判断
[root@server ~]# ((1==2));echo $?
[root@server ~]# ((1&lt;2));echo $?
[root@server ~]# ((2&gt;=1));echo $?
[root@server ~]# ((2!=1));echo $?
[root@server ~]# ((`id -u`==0));echo $?

[root@server ~]# ((a=123));echo $a
[root@server ~]# unset a
[root@server ~]# ((a==123));echo $?
字符串比较
注意：双引号引起来，看作一个整体；= 和 == 在 [ 字符串 ] 比较中都表示判断
[root@server ~]# a=&#39;hello world&#39;;b=world
[root@server ~]# [ $a = $b ];echo $?
[root@server ~]# [ &quot;$a&quot; = &quot;$b&quot; ];echo $?
[root@server ~]# [ &quot;$a&quot; != &quot;$b&quot; ];echo $?
[root@server ~]# [ &quot;$a&quot; !== &quot;$b&quot; ];echo $?错误
[root@server ~]# [ &quot;$a&quot; == &quot;$b&quot; ];echo $?
[root@server ~]# test &quot;$a&quot; != &quot;$b&quot;;echo $?


test  表达式
[ 表达式 ]
[[ 表达式 ]]

思考：[ ] 和 [[ ]] 有什么区别？

[root@server ~]# a=
[root@server ~]# test -z $a;echo $?
[root@server ~]# a=hello
[root@server ~]# test -z $a;echo $?
[root@server ~]# test -n $a;echo $?
[root@server ~]# test -n &quot;$a&quot;;echo $?

# [ &#39;&#39; = $a ];echo $?
-bash: [: : unary operator expected
2
# [[ &#39;&#39; = $a ]];echo $?
0


[root@server ~]# [ 1 -eq 0 -a 1 -ne 0 ];echo $?
[root@server ~]# [ 1 -eq 0 &amp;&amp; 1 -ne 0 ];echo $?
[root@server ~]# [[ 1 -eq 0 &amp;&amp; 1 -ne 0 ]];echo $?</code></pre>
<p>判断语句基本流程</p>
<pre><code>if [ condition1 ];then
command1
if [ condition2 ];then
command2
fi
 else
if [ condition3 ];then
command3
elif [ condition4 ];then
command4
else
command5
fi
fi</code></pre>
<h1 id="循环语句基本流程"><a href="#循环语句基本流程" class="headerlink" title="循环语句基本流程"></a>循环语句基本流程</h1><h2 id="for-语句循环"><a href="#for-语句循环" class="headerlink" title="for 语句循环"></a>for 语句循环</h2><p> ##<br>    for variable in {list}<br>            do<br>                command<br>                command<br>            done<br>    for variable in {list} ;do command command ;done</p>
<pre><code>for(( expr1;expr2;expr3 ))
do
command
command
…
done
for (( i=1;i&lt;=5;i++))
do
echo $i
done


expr1：定义变量并赋初值
expr2：决定是否进行循环（条件）
expr3：决定循环变量如何改变，决定循环什么时候退出</code></pre>
<h2 id="while-语句循环"><a href="#while-语句循环" class="headerlink" title="while 语句循环"></a>while 语句循环</h2><pre><code>while 表达式
    do
        command
    done

while  [ 1 -eq 1 ] 或者 (( 1 &gt; 2 ))
  do
 command
 ...
 done</code></pre>
<h2 id="until语句循环"><a href="#until语句循环" class="headerlink" title="until语句循环"></a>until语句循环</h2><pre><code>until expression   [ 1 -eq 1 ]  (( 1 &gt;= 1 ))
do
command
command
...
done</code></pre>
]]></content>
      <categories>
        <category>shell语句基础篇</category>
      </categories>
  </entry>
</search>
