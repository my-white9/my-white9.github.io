<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>//index.html</url>
    <content><![CDATA[<h1 id="awk-sed-find实战"><a href="#awk-sed-find实战" class="headerlink" title="awk+sed+find实战"></a>awk+sed+find实战</h1><p>##sed r w<br>w命令 </p>
<pre><code># sed &#39;/root/w 2.txt&#39; /etc/passwd </code></pre>
<p>将匹配到的包含root的行另存为2.txt文件 </p>
<h2 id="sed实战"><a href="#sed实战" class="headerlink" title="sed实战"></a>sed实战</h2><blockquote>
<p>将任意数字替换成空或者制表符</p>
</blockquote>
<pre><code>sed -r &#39;s/[0-9]/\t/gp&#39; a.txt </code></pre>
<blockquote>
<p>匹配root关键字替换成hello itcast，并保存到test.txt文件中<br><code>sed -r -n &#39;s/root/hello itcast/gp&#39; &gt; test.txt</code> </p>
</blockquote>
<p>去掉文件1-5行中的数字、冒号、斜杠</p>
<pre><code>sed -r -e -n 1,5s/[0-9]//gp a.txt</code></pre>
<blockquote>
<p>删除vsftpd.conf、smb.conf、main.cf配置文件里所有注释的行及空行（不要直接修改原文件）</p>
</blockquote>
<pre><code>sed  &#39;/^#/d;/^$/d&#39; vsftpd.conf</code></pre>
<blockquote>
<p>使用sed命令截取自己的ip地址</p>
</blockquote>
<p><code>sed -nr &#39;/[0-9]&#123;1,3&#125;.&#123;3&#125;[0-9]&#123;1,3&#125;/p&#39; 1.tx</code>t </p>
<blockquote>
<p>使用sed命令一次性截取ip地址、广播地址、子网掩码</p>
</blockquote>
<pre><code>ifconfig ens33 |sed -n &#39;2p&#39; |sed -n &#39;s/inet//pg&#39;|sed -n &#39;s/netmask//gp&#39;|sed -n &#39;s/broadcast//gp&#39; </code></pre>
<blockquote>
<p>注释掉文件的2-3行和匹配到以root开头或者以ftp开头的行</p>
</blockquote>
<pre><code>sed -nr &#39;2,3s/^/#&amp;/p;s/^ROOT|^ftp/#&amp;/p&#39; 1.txt</code></pre>
<p>awk<br>    从第一行开始匹配到以lp开头行<br>    awk -F: ‘NR==1,/^lp/{print $0 }’ passwd<br>    从第一行到第5行<br>    awk -F: ‘NR==1,NR==5{print $0 }’ passwd<br>    从以lp开头的行匹配到第10行<br>    awk -F: ‘/^lp/,NR==10{print $0 }’ passwd<br>    从以root开头的行匹配到以lp开头的行<br>    awk -F: ‘/^root/,/^lp/{print $0}’ passwd<br>    打印以root开头或者以lp开头的行<br>    awk -F: ‘/^root/ || /^lp/{print $0}’ passwd<br>    awk -F: ‘/^root/;/^lp/{print $0}’ passwd<br>    显示5-10行<br>    awk -F’:’ ‘NR&gt;=5 &amp;&amp; NR&lt;=10 {print $0}’ /etc/passwd<br>    awk -F: ‘NR&lt;10 &amp;&amp; NR&gt;5 {print $0}’ passwd</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>//index.html</url>
    <content><![CDATA[<p>基础知识和基础命令<br>基础目录</p>
<blockquote>
<pre><code>root  系统用户家目录
home  普通用户家目录
etc    配置文件
dev     设备文件 用于挂载
boot    启动文件
bin     用户命令文件
sbin    超级用户命令文件
var     实体文件(存放日志)
usr     第三方软件文件
tmp     临时文件
lib     库文件</code></pre>
</blockquote>
<pre><code>运行级别
&gt; 0-6
&gt; 0  关机 runlevel0.target   
&gt; 1  单用户超级用户不联网   runlevel0.target 
&gt; 2  多用户模式不联网  runlevel0.target 
&gt; 3   服务器模式无图形化runlevel0.target 
&gt; 4保留定制runlevel0.target 
&gt; 5    图形化模式 runlevel0.target 
&gt; 6    重新启动   runlevel0.target 

在/usr/lib/systemd/system中

基础命令:

常忘命令，其他的查看百度：
rm -f 强制删除文件
    -rf 强制删除
    -d 删除目录

cp   【参数】 源地址 现有地址
    常用： -a=-dpR
      -d 创建一个新的快捷方式
      -R 递归处理
      -p 自动满足创建创建文件的条件
      -i 复制之前询问是否要覆盖
      -s 建立个符号链接相当于快捷方式

vim 常用的快捷方式
    gg到文件第一行
    G到文件最后一行
    5G到指定的一行
    0到行首
    $到行尾
    ctrl + b 向上滚动一屏
    ctrl + f 向下滚动一屏
    A行尾插入
    参考:https://so.html5.qq.com/page/real/search_news?docid=70000021_4945f48d83c14014

bash常用快捷方式
    ctrl + a 移至行首
    ctrl + e 移至行尾
    ctrl + k 删除到行尾
    ctrl + f 删除到行首
    alt +f   向右移到单词的末尾
    alt +b   想做移动到一个单词的首部</code></pre>
]]></content>
  </entry>
  <entry>
    <title>正则表达式+文件处理</title>
    <url>/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/index.html</url>
    <content><![CDATA[<h1 id="正则表达式-文件处理"><a href="#正则表达式-文件处理" class="headerlink" title="正则表达式+文件处理"></a>正则表达式+文件处理</h1><h2 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h2><blockquote>
<p>匹配多重语句 ，匹配成功执行相匹配的命令</p>
</blockquote>
<h2 id="1-语法结构"><a href="#1-语法结构" class="headerlink" title="1.语法结构"></a>1.语法结构</h2><pre><code>说明：pattern表示需要匹配的模式


case var in 定义变量;var代表是变量名
pattern 1)  模式1;用 | 分割多个模式，相当于or
command1需要执行的语句
;;  两个分号代表命令结束
pattern 2)
command2
;;
pattern 3)
command3
;;
  *)  default，不满足以上模式，默认执行*)下面的语句
command4
;;
esacesac表示case语句结束</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数:"></a>函数:</h2><p>什么是函数 :<br>shell语序将一些命令的集合或语句形成一段有用的代码，成为shell 函数<br>给这段代码起个函数名，后续可以直接调取该代码的功能</p>
<pre><code>方法1：

函数名()
&#123;
  函数体（一堆命令的集合，来实现某个功能）   
&#125;
方法2：

function 函数名()
&#123;
   函数体（一堆命令的集合，来实现某个功能）
   echo hello
   echo world
&#125;</code></pre>
<p>resturn:默认结束一个函数并把最后一个状态值返回给函数，可以指定返回</p>
<h1 id="正则表达式-vim-awk-sed"><a href="#正则表达式-vim-awk-sed" class="headerlink" title="正则表达式+vim+awk+sed"></a>正则表达式+vim+awk+sed</h1><p>正则普通常用元字符</p>
<pre><code>.    匹配除了换行符以外的任意单个字符    
*    前导字符出现0次或连续多次    
.*    任意长度字符    ab.*
^    行首(以...开头)    ^root
$    行尾(以...结尾)    bash$
^$    空行    
[]    匹配括号里任意单个字符或一组单个字符    [abc]
匹配不包含括号里任一单个字符或一组单个字符    abc
^[]    匹配以括号里任意单个字符或一组单个字符开头    ^[abc]
^    匹配不以括号里任意单个字符或一组单个字符开头    ^[^abc]</code></pre>
<p>其他常用元字符</p>
<pre><code>元字符    功能    备注
\&lt;    取单词的头    
\&gt;    取单词的尾    
\&lt; \&gt;    精确匹配    
\&#123;n\&#125;    匹配前导字符连续出现n次    
\&#123;n,\&#125;    匹配前导字符至少出现n次    
\&#123;n,m\&#125;    匹配前导字符出现n次与m次之间    
\( \)    保存被匹配的字符    
\d    匹配数字（grep -P）    [0-9]
\w    匹配字母数字下划线（grep -P）    [a-zA-Z0-9_]
\s    匹配空格、制表符、换页符（grep -P）    [\t\r\n]</code></pre>
<p>扩展类正则常用元字符</p>
<p>grep 加-E 或者用egrep<br>sed用  加 -r</p>
<pre><code>扩展元字符    功能    备注
+    匹配一个或多个前导字符    bo+ 匹配boo、 bo
?    匹配零个或一个前导字符    bo? 匹配b、 bo
\        或    a\    b匹配a或b
()    组字符（看成整体）    (my\    your)self：表示匹配myself或匹配yourself
&#123;n&#125;    前导字符重复n次    
&#123;n,&#125;    前导字符重复至少n次    
&#123;n,m&#125;    前导字符重复n到m次</code></pre>
<p>正则表达式总结<br>把握一个原则，让你轻松搞定可恶的正则符号：</p>
<pre><code>我要找什么？
找数字 [0-9]
找字母 [a-zA-Z]
找标点符号 [[:punct:]]
我要如何找？看心情找
以什么为首 ^key
以什么结尾 key$
包含什么或不包含什么 [abc] \^[abc] [\^abc] \^[\^abc]
我要找多少呀？
找前导字符出现0次或连续多次 ab*
找任意单个(一次)字符 ab.
找任意字符 ab.*
找前导字符连续出现几次 &#123;n&#125; &#123;n,m&#125; &#123;n,&#125;
找前导字符出现1次或多次 go+
找前到字符出现0次或1次 go?</code></pre>
<p>正则元字符一栏表<br>    元字符：在正则中，具有特殊意义的专用字符，如: 星号(*)、加号(+)等</p>
<pre><code>前导字符：元字符前面的字符叫前导字符

元字符    功能    示例
*    前导字符出现0次或者连续多次    ab* abbbb
.    除了换行符以外，任意单个字符    ab. ab8 abu
.*    任意长度的字符    ab.* abdfdfdf
[]    括号里的任意单个字符或一组单个字符    [abc][0-9][a-z]
不匹配括号里的任意单个字符或一组单个字符    abc
^[]    匹配以括号里的任意单个字符开头    ^[abc]
^    不匹配以括号里的任意单个字符开头    
^    行的开头    ^root
$    行的结尾    bash$
^$    空行    
\&#123;n\&#125;和&#123;n&#125;    前导字符连续出现n次    [0-9]\&#123;3\&#125;
\&#123;n,\&#125;和&#123;n,&#125;    前导字符至少出现n次    [a-z]&#123;4,&#125;
\&#123;n,m\&#125;和&#123;n,m&#125;    前导字符连续出现n-m次    go&#123;2,4&#125;
\&lt;\&gt;    精确匹配单词    \
\(\)    保留匹配到的字符    \(hello\)
+    前导字符出现1次或者多次    [0-9]+
?    前导字符出现0次或者1次    go?
\        或    ^root\    ^ftp
()    组字符    (hello\    world)123
\d    匹配数字（grep -P）    grep -P \d+
\w    匹配字母数字下划线（grep -P）    
\s    匹配空格、制表符、换页符（grep -P）
\d、\w、\s为perl内置正则，使用时需加-P选项。</code></pre>
<p>grep：数据查找定位</p>
<p>awk：数据切片</p>
<p>sed：数据修改</p>
<h2 id="sed介绍"><a href="#sed介绍" class="headerlink" title="sed介绍"></a>sed介绍</h2><p>一行一行读取并按要求处理，把处理结果输出到屏幕<br>语法:<br>     语法格式<br>    sed [options] ‘处理动作’ 文件名</p>
<pre><code>常用选项
选项    说明    备注
-e    进行多项(多次)编辑    
-n    取消默认输出    不自动打印模式空间
-r    使用扩展正则表达式    
-i    原地编辑（修改源文件）    
-f    指定sed脚本的文件名
常见处理动作


动作    说明    备注
&#39;p&#39;    打印    
&#39;i&#39;    在指定行之前插入内容    类似vim里的大写O
&#39;a&#39;    在指定行之后插入内容    类似vim里的小写o
&#39;c&#39;    替换指定行所有内容    
&#39;d&#39;    删除指定行</code></pre>
<p>对文件进行搜索替换操作</p>
<blockquote>
<p>语法：sed 选项 ‘s/搜索的内容/替换的内容/动作’ 需要处理的文件</p>
<p>其中，s表示search搜索；斜杠/表示分隔符，可以自己定义;动作一般是打印p和全局替换g（默认只替换每行第一个匹配到的内容）</p>
</blockquote>
<p> 其他命令</p>
<pre><code>命令    解释    备注
r    从另外文件中读取内容    
w    内容另存为    
&amp;    保存查找串以便在替换串中引用    和\(\)相同
=    打印行号    
！    对所选行以外的所有行应用命令，放到行数之后    &#39;1,5!&#39;
q    退出</code></pre>
<p>sed结合正则使用<br>sed 选项 ‘sed命令或者正则表达式或者地址定位’ 文件名</p>
<p>定址用于决定对哪些行进行编辑。地址的形式可以是数字、正则表达式、或二者的结合。<br>如果没有指定地址，sed将处理输入文件的所有行。</p>
<pre><code>正则    说明    备注
/key/    查询包含关键字的行    sed -n &#39;/root/p&#39; 1.txt
/key1/,/key2/    匹配包含两个关键字之间的行    sed -n &#39;/\^adm/,/^mysql/p&#39; 1.txt
/key/,x    从匹配关键字的行开始到文件第x行之间的行（包含关键字所在行）    sed -n &#39;/^ftp/,7p&#39;
x,/key/    从文件的第x行开始到与关键字的匹配行之间的行    
x,y!    不包含x到y行    
/key/!    不包括关键字的行    sed -n &#39;/bash$/!p&#39; 1.txt</code></pre>
<h2 id="awk介绍"><a href="#awk介绍" class="headerlink" title="awk介绍"></a>awk介绍</h2><blockquote>
<p>awk的处理文本和数据的方式：逐行扫描文件，默认从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。</p>
<p>awk用来处理文件和数据的，是类unix下的一个工具，也是一种编程语言</p>
<p>可以用来统计数据，比如网站的访问量，访问的IP量等等</p>
<p>支持条件判断，支持for和while循环</p>
</blockquote>
<pre><code>awk 选项 &#39;命令部分&#39; 文件名
-F 定义字段分割符号，默认的分隔符是空格
-v 定义变量并赋值</code></pre>
<p>awk 选项 -f awk的脚本文件  要处理的文本文件<br>    awk -f awk.sh filename</p>
<pre><code>sed -f sed.sh -i filename

方法2：
./awk的脚本文件(或者绝对路径)要处理的文本文件
./awk.sh filename

./sed.sh filename</code></pre>
<p>awk内部相关变量</p>
<pre><code>变量    变量说明    备注
$0    当前处理行的所有记录    
$1,$2,$3...$n    文件中每行以间隔符号分割的不同字段    awk -F: &#39;&#123;print $1,$3&#125;&#39;
NF    当前记录的字段数（列数）    awk -F: &#39;&#123;print NF&#125;&#39;
$NF    最后一列    $(NF-1)表示倒数第二列
FNR/NR    行号    
FS    定义间隔符，默认空格    &#39;BEGIN&#123;FS=&quot;:&quot;&#125;;&#123;print $1,$3&#125;&#39;
OFS    定义输出字段分隔符，默认空格    &#39;BEGIN&#123;OFS=&quot;\t&quot;&#125;;&#123;print $1,$3&#125;&#39;
RS    输入记录分割符，默认换行（行结束判断标志）    &#39;BEGIN&#123;RS=&quot;\t&quot;&#125;;&#123;print $0&#125;&#39;
ORS    输出记录分割符，默认换行    &#39;BEGIN&#123;ORS=&quot;\n\n&quot;&#125;;&#123;print $1,$3&#125;&#39;
FILENAME    当前输入的文件名</code></pre>
<p>grep 查询</p>
<pre><code>-a --text  # 不要忽略二进制数据。
-A &lt;显示行数&gt;   --after-context=&lt;显示行数&gt;   # 除了显示符合范本样式的那一行之外，并显示该行之后的内容。
-b --byte-offset   # 在显示符合范本样式的那一行之外，并显示该行之前的内容。
-B&lt;显示行数&gt;   --before-context=&lt;显示行数&gt;   # 除了显示符合样式的那一行之外，并显示该行之前的内容。
-c --count# 计算符合范本样式的列数。
-C&lt;显示行数&gt; --context=&lt;显示行数&gt;或-&lt;显示行数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
-d&lt;进行动作&gt; --directories=&lt;动作&gt;  # 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。
-e&lt;范本样式&gt; --regexp=&lt;范本样式&gt;   # 指定字符串作为查找文件内容的范本样式。
-E --extended-regexp # 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。
-f&lt;范本文件&gt; --file=&lt;规则文件&gt; # 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。
-F --fixed-regexp   # 将范本样式视为固定字符串的列表。
-G --basic-regexp   # 将范本样式视为普通的表示法来使用。
-h --no-filename# 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
-H --with-filename  # 在显示符合范本样式的那一列之前，标示该列的文件名称。
-i --ignore-case# 忽略字符大小写的差别。
-l --file-with-matches   # 列出文件内容符合指定的范本样式的文件名称。
-L --files-without-match # 列出文件内容不符合指定的范本样式的文件名称。
-n --line-number # 在显示符合范本样式的那一列之前，标示出该列的编号。
-P --perl-regexp # PATTERN 是一个 Perl 正则表达式
-q --quiet或--silent # 不显示任何信息。
-R/-r  --recursive   # 此参数的效果和指定“-d recurse”参数相同。
-s --no-messages  # 不显示错误信息。
-v --revert-match # 反转查找。
-V --version  # 显示版本信息。   
-w --word-regexp  # 只显示全字符合的列。
-x --line-regexp  # 只显示全列符合的列。
-y # 此参数效果跟“-i”相同。
-o # 只输出文件中匹配到的部分。
-m &lt;num&gt; --max-count=&lt;num&gt; # 找到num行结果后停止查找，用来限制匹配行数

^# 锚定行的开始 如：&#39;^grep&#39;匹配所有以grep开头的行。
$# 锚定行的结束 如：&#39;grep$&#39; 匹配所有以grep结尾的行。
.# 匹配一个非换行符的字符 如：&#39;gr.p&#39;匹配gr后接一个任意字符，然后是p。
*# 匹配零个或多个先前字符 如：&#39;*grep&#39;匹配所有一个或多个空格后紧跟grep的行。
.*   # 一起用代表任意字符。   
[]   # 匹配一个指定范围内的字符，如&#39;[Gg]rep&#39;匹配Grep和grep。
[^]  # 匹配一个不在指定范围内的字符，如：&#39;[^A-FH-Z]rep&#39;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。
\(..\)  # 标记匹配字符，如&#39;\(love\)&#39;，love被标记为1。
\&lt;  # 锚定单词的开始，如:&#39;\&lt;grep&#39;匹配包含以grep开头的单词的行。
\&gt;  # 锚定单词的结束，如&#39;grep\&gt;&#39;匹配包含以grep结尾的单词的行。
x\&#123;m\&#125;  # 重复字符x，m次，如：&#39;0\&#123;5\&#125;&#39;匹配包含5个o的行。
x\&#123;m,\&#125;   # 重复字符x,至少m次，如：&#39;o\&#123;5,\&#125;&#39;匹配至少有5个o的行。
x\&#123;m,n\&#125;  # 重复字符x，至少m次，不多于n次，如：&#39;o\&#123;5,10\&#125;&#39;匹配5--10个o的行。   
\w# 匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#39;G\w*p&#39;匹配以G后跟零个或多个文字或数字字符，然后是p。   
\W# \w的反置形式，匹配一个或多个非单词字符，如点号句号等。   
\b# 单词锁定符，如: &#39;\bgrep\b&#39;只匹配grep。  </code></pre>
]]></content>
      <categories>
        <category>shell语句基础篇</category>
      </categories>
  </entry>
  <entry>
    <title>语句脚本实战</title>
    <url>/%E8%AF%AD%E5%8F%A5%E8%84%9A%E6%9C%AC%E5%AE%9E%E6%88%98/index.html</url>
    <content><![CDATA[<p>if语句</p>
<h2 id="判断一个服务是否正常"><a href="#判断一个服务是否正常" class="headerlink" title="判断一个服务是否正常"></a>判断一个服务是否正常</h2><pre><code>#!/bin/env bash
read -p service service
systemctl status $service |grep running &amp;&gt; /dev/null
if [ $? -eq 0 ];then
    echo &quot;$service excited&quot; 
else
    echo &quot;$service not excited&quot;
fi</code></pre>
<h2 id="判断用户是否存在"><a href="#判断用户是否存在" class="headerlink" title="判断用户是否存在"></a>判断用户是否存在</h2><pre><code>#!/bin/env bash
#Name: user excited

read -p &quot;user:&quot; user
id $user &amp;&gt; /dev/null
if [ $? -eq 0 ] ;then
    echo &quot;$user has excited&quot;
else
    echo &quot;$user not excited&quot;
fi</code></pre>
<h2 id="判断软件包是否安装"><a href="#判断软件包是否安装" class="headerlink" title="判断软件包是否安装"></a>判断软件包是否安装</h2><pre><code>#!/bin/env bash
#Name: user excited

read -p &quot;rpm&quot; rpm
rpm -qa |grep $rpm  &amp;&gt; /dev/null
if [ $? -eq 0 ] ;then
    echo &quot;$rpm has excited&quot;
else
    echo &quot;$rpm not excited&quot;
fi</code></pre>
<h2 id="判断当前主机的内核版本"><a href="#判断当前主机的内核版本" class="headerlink" title="判断当前主机的内核版本"></a>判断当前主机的内核版本</h2><pre><code>#!/bin/env bash
number=$(uname -r)
version1=$&#123;number:0:1&#125;
version2=$&#123;number:2:1&#125;
if [ $version1 -eq 2 -a $version2 -ge 6 ] ;then
    echo &quot;$number&quot;
else
    echo &quot;no&quot;
fi</code></pre>
<h2 id="批量创建用户"><a href="#批量创建用户" class="headerlink" title="批量创建用户"></a>批量创建用户</h2><p>需求：批量加5个新用户，以u1到u5命名，并统一加一个新组，组名为class,统一改密码为123</p>
<pre><code>#!/bin/env bash
Name: create user
grep -w ^class /etc/group &amp;&gt;/dev/null
test $? -ne 0 &amp;&amp; groupadd class
for ((i=1;i&lt;=5;i++))
do
    useradd -G class u$i
    echo 123 |passwd --stdin u$i
done</code></pre>
<p>~        </p>
<h2 id="批量创建用户-1"><a href="#批量创建用户-1" class="headerlink" title="批量创建用户"></a>批量创建用户</h2><p>需求1:批量新建5个用户stu1~stu5，要求这几个用户的家目录都在/rhome.<br>    #!/bin/env bash<br>    for x in {1..5};<br>    do<br>        mkdir -p /rhome/stu$x<br>        usermod  -d /rhome/stu$x stu$x<br>    done</p>
<h2 id="局域网内脚本检查主机网络通讯"><a href="#局域网内脚本检查主机网络通讯" class="headerlink" title="局域网内脚本检查主机网络通讯"></a>局域网内脚本检查主机网络通讯</h2><p>需求2：</p>
<p>写一个脚本，局域网内，把能ping通的IP和不能ping通的IP分类，并保存到两个文本文件里</p>
<p>以10.1.1.1~10.1.1.10为例</p>
<pre><code>#!/bin/env bash
for ip in &#123;1..10&#125;
do
    ip=192.168.0.$ip
    ping -c1 $ip &amp;&gt;/dev/null
if [ $? -eq 0 ] ;then
    echo &quot;$ip&quot; &gt;&gt;  /ip.txt
else
       echo &quot;$ip&quot; &gt;&gt; /ip1.txt
fi
done</code></pre>
<h2 id="延伸扩展：shell脚本并发"><a href="#延伸扩展：shell脚本并发" class="headerlink" title="延伸扩展：shell脚本并发"></a>延伸扩展：shell脚本并发</h2><h2 id="脚本同步系统时间"><a href="#脚本同步系统时间" class="headerlink" title="脚本同步系统时间"></a>脚本同步系统时间</h2><p>① 具体需求<br>写一个脚本，30秒同步一次系统时间，时间同步服务器192.168.0.139<br>如果同步失败，则进行邮件报警,每次失败都报警<br>如果同步成功,也进行邮件通知,但是成功100次才通知一次</p>
<blockquote>
<p>1.死循环<br>2.同步命令 ntpdate 192.168.0.1<br>3.同步成功计数，条件到达100报警</p>
</blockquote>
<pre><code>#!/bin/env bash
i=0
while true
do
ntpdate 114.118.7.161 &amp;&gt;/dev/null
if [ $? -eq 0 ] ;then
    let i++
    if [ $i -eq 100 ];then
        echo &quot;system date success&quot;| mail -s &quot;success&quot; root@localhost
        let i=0
else
        echo &quot;system date false&quot;|mail -s &quot;false&quot; root@localhost
        echo &quot;count:&quot;$i
    fi
fi
sleep 3
done</code></pre>
<h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><p>㈠ 具体需求 ##<br>使用until语句批量创建10个用户，要求stu1—stu5用户的UID分别为1001—1005；<br>stu6~stu10用户的家目录分别在/rhome/stu6—/rhome/stu10</p>
<p>创建10个用户条件为真推出</p>
<pre><code>#!/bin/env bash
ls /rhome &amp;&gt;/dev/null
if [ $? -ne  0 ];then
    mkdir /rhome
else
    echo &#39;excited&#39;
fi
count=0
until [ $count -gt 10 ]
do
    for x in &#123;1..10&#125;
    do
        if [ $x -ge 6 ];then
            let count++
               useradd -d /rhome/stu$x stu$x
        else
            let count++
            useradd -u 100$x stu$x
        fi
    done
done</code></pre>
<p>判断/tmp/run目录是否存在，如果不存在就建立，如果存在就删除目录里所有文件</p>
<pre><code>#！/bin/env bash
if [ -d /tmp/run ];then
    rm -rf /tmp/run
else
    mkdir -p /tmp/run</code></pre>
<p>输入一个路径，判断路径是否存在，而且输出是文件还是目录，如果是链接文件，还得输出是 有效的连接还是无效的连接</p>
<pre><code>#!/bin/env bash
read -p dir dir
if [ -e $dir ];then
    if [ -d $dir ];then
        echo $dir
    else
        if [ -f $dir ];then
            echo &quot;yes it is document&quot;   
        else
            echo “not document”
            if [ -S $dir ];then
                echo &quot;effective&quot;
            else
                echo &quot;not effective&quot;
            fi
        fi
    fi
fi</code></pre>
<p>交互模式要求输入一个ip，然后脚本判断这个IP 对应的主机是否 能ping 通，输出结果类似于： Server 10.1.1.20 is Down! 最后要求把结果邮件到本地管理员root@localhost mail01@localhost</p>
<pre><code>#!/bin/env bash
read -p ip ip
ping -c1 $ip &amp;&gt;/dev/null
if [ $? -eq 0 ] ;then
    echo &quot;Server $x is Down!&quot;
    echo &quot;Server $x is Down!&quot;|mail -s &quot;success&quot; root@localhost
    echo &quot;Server $x is Down!&quot;|mail -s &quot;success&quot; mail01@localhost
else
    echo &quot;it is defect&quot;
fi</code></pre>
<p>写一个脚本/home/program，要求当给脚本输入参数hello时，脚本返回world,给脚本输入参数world时，脚本返回hello。而脚本没有参数或者参数错误时，屏幕上输出“usage:/home/program hello or world”</p>
<pre><code>#!/bin/env bash
read -p &quot;please put in&quot; input
hello=hello
world=world
if [ $input == $hello ];then
    echo &quot;world&quot;
elif [ $input == $world ];then
    echo &quot; hello &quot;
else
    echo &quot;usage:/home/program hello or world&quot;
fi</code></pre>
<p>写一个脚本自动搭建nfs服务</p>
<blockquote>
<p>1.先判断有没有nfs服务是否安装</p>
</blockquote>
<blockquote>
<p>2.rpcbind服务是否安装</p>
</blockquote>
<blockquote>
<p>3.判断双方网络是否通畅</p>
</blockquote>
<blockquote>
<p>4.关闭selinux以及防火墙</p>
</blockquote>
<blockquote>
<p>5.创建和发布共享目录</p>
</blockquote>
<blockquote>
<p>6.开机启动以及启动服务</p>
</blockquote>
<pre><code>#!/bin/env bash
rpm -qa|grep nfs-util &amp;&gt;/dev/null

if [ $? -eq 0 ] ;then
    echo &quot;nfs installed&quot;
else
    yum install nfs-util* -y
    echo &quot;===============
             install&quot;
fi
rpm -qa|grep rpcbind &amp;&gt;/dev/null
if [ $? -eq 0 ] ;then
    echo &quot;rpmbind installed&quot;
else
    yum install rpcbind* -y
    echo &quot;===============
             install&quot;
fi
read -p ip ip
ping -c1 $ip &amp;&gt;/dev/null
if [ $? -eq 0 ];then
    echo &quot;ok&quot;
else
    echo &quot;please change your ip&quot;
fi
setenforce 0 &gt;/dev/null &amp;&amp; echo &quot;selinux closed&quot;
systemctl stop firewall /dev/null &amp;&amp; echo &quot;firewwalld has closed&quot;
read -p &quot;please input dir&quot; dir
mkdir -p $dir
chmod 777 $dir
read -p &quot;ip:&quot; ip
read -p &quot;rw/ro:&quot; fal
cat &gt;&gt;/etc/export &lt;&lt; end
$dir $ip($fal)
end

systemctl restart rpcbind
systemctl restart nfs
echo &quot;ok&quot;</code></pre>
]]></content>
      <categories>
        <category>shell语句基础篇</category>
      </categories>
  </entry>
  <entry>
    <title>分类</title>
    <url>/%E5%88%86%E7%B1%BB/index.html</url>
    <content><![CDATA[<h1 id="课程目标："><a href="#课程目标：" class="headerlink" title="课程目标："></a>课程目标：</h1><p>熟练使用shell变量语句<br>能够编写简单的系统工具脚本<br>熟练使用awk，grep，find<br>shell介绍：<br>1.shell是解释型语言：效率低每使用一次都要进行翻译 使用解释器/bin/sh /bin/bash<br>2.sh是链接到bash无区别<br>3.对兼容性有要求会一般使用解释型语言</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>shell是人机交互的一个桥梁，负责将计算机用户的输入进行翻译来控制linux内核</p>
<h1 id="shell的种类："><a href="#shell的种类：" class="headerlink" title="shell的种类："></a>shell的种类：</h1><pre><code>[root@MissHou ~]# cat /etc/shells 
/bin/sh#是bash的一个快捷方式
/bin/bash#bash是大多数Linux默认的shell，包含的功能几乎可以涵盖shell所有的功能
/sbin/nologin#表示非交互，不能登录操作系统
/bin/dash#小巧，高效，功能相比少一些
/bin/csh#具有C语言风格的一种shell，具有许多特性，但也有一些缺陷
/bin/tcsh#是csh的增强版，完全兼容csh
常用：/bin/bash</code></pre>
<p>shell常用于编写脚本批量的处理一些问题</p>
<p>shell脚本：</p>
<h1 id="1-脚本第一行："><a href="#1-脚本第一行：" class="headerlink" title="1.脚本第一行："></a>1.脚本第一行：</h1><h2 id="！-bin-bash-使用bash解释器"><a href="#！-bin-bash-使用bash解释器" class="headerlink" title="#！/bin/bash 使用bash解释器"></a>#！/bin/bash 使用bash解释器</h2><p>注意：考虑到脚本的可移植性，因此使用/bin/env bash  env会自动的到$PATH中查找bash的可执行文件</p>
<p>!/bin/env bash和 #!/usr/bin/env bash 的区别在于 /bin只有root用户访问更加的安全</p>
<h1 id="2-脚本第二部分"><a href="#2-脚本第二部分" class="headerlink" title="2.脚本第二部分"></a>2.脚本第二部分</h1><pre><code>#!/bin/env bash
#以下是对脚本的基本信息的描述
#Name:
#Desc:
#Path:
#Usage:#用法
#Update:   #更新时间

#下面就是脚本的具体内容
commands</code></pre>
<h1 id="3-脚本第三部分：脚本具体的代码"><a href="#3-脚本第三部分：脚本具体的代码" class="headerlink" title="3.脚本第三部分：脚本具体的代码"></a>3.脚本第三部分：脚本具体的代码</h1><p>基础：编写一个脚本</p>
<pre><code>#!/bin/env bash
#Name: test
#Desc: test
#Path: /tmp/shell/test.sh
#Usage: be used to test
#Update: 2020-10-19

echo &quot;this is a test&quot;
echo &quot;hello world&quot;

[root@zabbix ~]# chmod +x /tmp/test.sh 
[root@zabbix ~]# /tmp/test.sh 
this is a test
hello world
[root@zabbix ~]# bash -x /tmp/test.sh  用于排错  指定解释器执行
+ echo &#39;this is a test&#39;
this is a test
+ echo &#39;hello world&#39;
hello world
[root@zabbix ~]# bash -n /tmp/test.sh 用于查看语法是否有错

bash /tmp/test.sh 和 sh /tmp/test.sh 都是用子shell进行
/tmp/test.sh 和 source /tmp/test.sh 是调用父shell</code></pre>
<h2 id="写一个脚本"><a href="#写一个脚本" class="headerlink" title="写一个脚本"></a>写一个脚本</h2><p>删除/tmp/目录下的所有文件</p>
<p>然后在/tmp目录里创建3个目录，分别是dir1~dir3</p>
<p>拷贝/etc/hosts文件到刚创建的dir1目录里</p>
<pre><code>#!/bin/env bash
#Name:
#Desc:
#Path:
#Update:
#Usage:

rm -rf /tmp/*
mkdir /tmp/dir&#123;1..3&#125;
cp /etc/hosts /tmp/dir1
echo &quot;finsh $(date +&#39;%F %T&#39;)&quot;</code></pre>
<h1 id="变量的定义："><a href="#变量的定义：" class="headerlink" title="变量的定义："></a>变量的定义：</h1><p>变量名区分大小写 不能有特殊符号 不可用数字开头 不可空格 驼峰命名</p>
<pre><code>A=hello
echo $(A)
hello
$&#123;A:2:4&#125;可以截取指定的
hell
unset $A 取消变量</code></pre>
<h2 id="交互式定义变量-read"><a href="#交互式定义变量-read" class="headerlink" title="交互式定义变量(read)"></a>交互式定义变量(read)</h2><pre><code>常见选项：

选项  释义
-p  定义提示用户的信息
-n  定义字符数（限制变量值的长度）
-s  不显示（不显示用户输入的内容）
-t  定义超时时间，默认单位为秒（限制用户输入变量值的超时时间）
[harry@zabbix ~]$ read -n3 &quot;input your name :&quot; name
111-bash: read: `input your name :&#39;: not a valid identifier
 read -s &quot;input your name :&quot; name
[harry@zabbix ~]$ read -p &quot;input your name :&quot; name
input your name :harry</code></pre>
<h2 id="变量来自文件"><a href="#变量来自文件" class="headerlink" title="变量来自文件"></a>变量来自文件</h2><pre><code>[harry@zabbix ~]$ read ip mask &lt; 1.txt
[harry@zabbix ~]$ echo $ip
10.0.0.1
[harry@zabbix ~]$ echo $mask
255.255.255.0
[harry@zabbix ~]$ cat 1.txt 
10.0.0.1 255.255.255.0 ##
定义有类型的变量(declare)
目的： 给变量做一些限制，固定变量的类型，比如：整型、只读</code></pre>
<h2 id="定义有类型的变量"><a href="#定义有类型的变量" class="headerlink" title="定义有类型的变量"></a>定义有类型的变量</h2><pre><code>用法：declare 选项 变量名=变量值

常用选项：

选项  释义  举例
-i  将变量看成整数 declare -i A=123
-r  定义只读变量  declare -r B=hello
-a  定义普通数组；查看普通数组   
-A  定义关联数组；查看关联数组   
-x  将变量通过环境导出   declare -x AAA=123456 等于 export AAA=123456
举例说明：

[root@MissHou ~]# declare -i A=123
[root@MissHou ~]# echo $A
123
[root@MissHou ~]# A=hello
[root@MissHou ~]# echo $A
0

[root@MissHou ~]# declare -r B=hello
[root@MissHou ~]# echo $B
hello
[root@MissHou ~]# B=world
-bash: B: readonly variable
[root@MissHou ~]# unset B
-bash: unset: B: cannot unset: readonly variable</code></pre>
<h2 id="本地变量："><a href="#本地变量：" class="headerlink" title="本地变量："></a>本地变量：</h2><pre><code>ps
ps auxf 查看所有进程   常用
-A显示所有进程（同-e）
-a显示当前终端的所有进程
-u显示进程的用户信息
-o以用户自定义形式显示进程信息
-f显示程序间的关系
echo $$ 查看当前的进程号</code></pre>
<h2 id="补充命令"><a href="#补充命令" class="headerlink" title="补充命令"></a>补充命令</h2><p>pgrep命令：以名称为依据从运行进程队列中查找进程，并显示查找到的进程id<br>选项<br>-o：仅显示找到的最小（起始）进程号;<br>-n：仅显示找到的最大（结束）进程号；<br>-l：显示进程名称；<br>-P：指定父进程号；pgrep -p 4764  查看父进程下的子进程id<br>-g：指定进程组；<br>-t：指定开启进程的终端；<br>-u：指定进程的有效用户ID。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量:"></a>全局变量:</h2><p>全局变量文件 ：全局所有的用户以及程序都能调用，默认继承<br>解读相关的配置文件</p>
<pre><code>文件名    说明    备注
~/.bashrc    当前用户的bash信息，用户登录时读取    局部。定义别名、umask、函数等
~/.bash_profile    当前用户的环境变量信息，用户登录时读取    局部。
~/.bash_logout    当前用户退出当前shell时最后读取    局部。定义用户退出时执行的程序等
~/.bash_history    当前用户的历史命令    局部。history -w保存历史记录 history -c清空历史记录
/etc/bashrc    全局的bash信息    全局。所有用户都生效
/etc/profile    全局环境变量信息    全局。系统和所有用户都生效
umask   默认0022 用于指定默认的创建文件的文件权限</code></pre>
<p>以上文件修改后需要source生效或者退出重新登陆<br>读取顺序: 环境变量:全局在用户前   bash变量：用户在全局前</p>
<pre><code>/etc/profile
$HOME /.bash_profile
$HOME /.bashrc
/etc/bashrc
$HOME/.bash_logout</code></pre>
<h2 id="环境变量："><a href="#环境变量：" class="headerlink" title="环境变量："></a>环境变量：</h2><p>环境变量:当前进程有效，且能够被子进程调用<br>env当前的环境变量 临时  直接加入<br>set当前用户的全部环境变量 临时和环境<br>export 变量名=变量值 或者 变量名=变量值；export 变量名 或者 declare -x 变量名=变量值  临时加入  放入全局配置文件中可更改永久配置</p>
<pre><code>[root@zabbix ~]# export A=hello
[root@zabbix ~]# env |grep ^A
A=hello
[root@zabbix ~]# set |grep ^A
A=hello
ABRT_DEBUG_LOG=/dev/null
[root@zabbix ~]# cat /etc/profile | grep A=hello
export A=hello</code></pre>
<h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><pre><code>内置bash中变量
系统变量(内置bash中变量) ： shell本身已经固定好了它的名字和作用.
内置变量    含义
$?    上一条命令执行后返回的状态；状态值为0表示执行正常，非0表示执行异常或错误
$0    当前执行的程序或脚本名
$#    脚本后面接的参数的个数
$*    脚本后面所有参数，参数当成一个整体输出，每一个变量参数之间以空格隔开
$@    脚本后面所有参数，参数是独立的，也是全部输出
$1~$9    脚本后面的位置参数，$1表示第1个位置参数，依次类推
$&#123;10&#125;~$&#123;n&#125;    扩展位置参数,第10个位置变量必须用&#123;&#125;大括号括起来(2位数字以上扩起来)
$$    当前所在进程的进程号，如echo $$
$！    后台运行的最后一个进程号 (当前终端）
!$    调用最后一条命令历史中的参数

[root@zabbix ~]# cat /bash.sh 
#!/bin/env bash
echo &quot;\$? = $?&quot;
echo &quot;\$0 = $0&quot;
echo &quot;\$# = $#&quot;
echo &quot;\$* = $*&quot;
echo &quot;\$@ = $@&quot;
echo &quot;\$1 = $1&quot; 
echo &quot;\$2 = $2&quot; 
echo &quot;\$3 = $3&quot; 
echo &quot;\$11 = $&#123;11&#125;&quot; 
echo &quot;\$12 = $&#123;12&#125;&quot;
echo &quot;\$$ = $$&quot;
echo &quot;\$! = $!&quot;
echo &quot;\!$ = !$&quot;
[root@zabbix ~]# sh /bash.sh  a b c d e f g h l 1 23 4 5 6 7 8
$? = 0
$0 = /bash.sh
$# = 16
$* = a b c d e f g h l 1 23 4 5 6 7 8
$@ = a b c d e f g h l 1 23 4 5 6 7 8
$1 = a
$2 = b
$3 = c
$11 = 23
$12 = 4
$$ = 14463
$! = 
\!$ = !$</code></pre>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><pre><code>表达式    举例    说明
$(( ))    echo $((1+1))    
$[ ]    echo $[10-5]    
expr    expr 10 / 5    expr程序中，数值与运算符之间需要空格隔开，乘(*)运算符需要用转义符( \ )转义，expr不能做幂运算
let    n=1;let n+=1 等价于 let n=n+1    let n=2 等价于let n=n\2，不能使用let n**=2</code></pre>
<h2 id="判断参数"><a href="#判断参数" class="headerlink" title="判断参数"></a>判断参数</h2><pre><code>    含义
-eq    相等
-ne    不等
-gt    大于
-lt    小于
-ge    大于等于
-le    小于等于</code></pre>
<h2 id="判断字符串"><a href="#判断字符串" class="headerlink" title="判断字符串"></a>判断字符串</h2><pre><code>判断参数    含义
-z    判断是否为空字符串，字符串长度为0则成立
-n    判断是否为非空字符串，字符串长度不为0则成立
string1 = string2    判断字符串是否相等
string1 != string2    判断字符串是否相不等</code></pre>
<h2 id="shell基本语句"><a href="#shell基本语句" class="headerlink" title="shell基本语句"></a>shell基本语句</h2><p> 条件判断</p>
<pre><code>if语句
判断文件类型
-e 是否存在
-d 是否是目录
-L 是否是套接字
-f 是否是普通文件
-b 是否是块文件
-S 是否是套接字文件
-c 是否是字符设备文字
-p 是否是命名管道文件
-s 是否是一个非空文件</code></pre>
<blockquote>
<p>条件判断语法格式</p>
<p>格式1： test 条件表达式</p>
<p>格式2： [ 条件表达式 ]</p>
<p>格式3： [[ 条件表达式 ]] 支持正则 =~</p>
</blockquote>
<p>判断文件新旧：修改时间<br>-nt   1是否比2新<br>-ot   1是否比2旧<br>-ef   1和2是否是同一文件</p>
<blockquote>
<p>多重条件判断<br>判断符号    含义    举例<br> 和 &amp;&amp;    逻辑与    [ 1 -<br> 1 -a 1 -ne 0 ] [ 1 -eq 1 ] &amp;&amp; [ 1 -ne 0 ]<br>-o 和 \    \        逻辑或    [ 1 -eq 1 -o 1 -ne 1 ] [ 1 -eq 1 ] \    \    [1 -ne 1]<br>特别说明：</p>
<p>&amp;&amp; 前面的表达式为真，才会执行后面的代码</p>
<p>|| 前面的表达式为假，才会执行后面的代码</p>
<p>; 只用于分割命令或表达式</p>
</blockquote>
<pre><code>类C风格的数值比较
注意：在(( ))中，=表示赋值；==表示判断
[root@server ~]# ((1==2));echo $?
[root@server ~]# ((1&lt;2));echo $?
[root@server ~]# ((2&gt;=1));echo $?
[root@server ~]# ((2!=1));echo $?
[root@server ~]# ((`id -u`==0));echo $?

[root@server ~]# ((a=123));echo $a
[root@server ~]# unset a
[root@server ~]# ((a==123));echo $?
字符串比较
注意：双引号引起来，看作一个整体；= 和 == 在 [ 字符串 ] 比较中都表示判断
[root@server ~]# a=&#39;hello world&#39;;b=world
[root@server ~]# [ $a = $b ];echo $?
[root@server ~]# [ &quot;$a&quot; = &quot;$b&quot; ];echo $?
[root@server ~]# [ &quot;$a&quot; != &quot;$b&quot; ];echo $?
[root@server ~]# [ &quot;$a&quot; !== &quot;$b&quot; ];echo $?错误
[root@server ~]# [ &quot;$a&quot; == &quot;$b&quot; ];echo $?
[root@server ~]# test &quot;$a&quot; != &quot;$b&quot;;echo $?


test  表达式
[ 表达式 ]
[[ 表达式 ]]

思考：[ ] 和 [[ ]] 有什么区别？

[root@server ~]# a=
[root@server ~]# test -z $a;echo $?
[root@server ~]# a=hello
[root@server ~]# test -z $a;echo $?
[root@server ~]# test -n $a;echo $?
[root@server ~]# test -n &quot;$a&quot;;echo $?

# [ &#39;&#39; = $a ];echo $?
-bash: [: : unary operator expected
2
# [[ &#39;&#39; = $a ]];echo $?
0


[root@server ~]# [ 1 -eq 0 -a 1 -ne 0 ];echo $?
[root@server ~]# [ 1 -eq 0 &amp;&amp; 1 -ne 0 ];echo $?
[root@server ~]# [[ 1 -eq 0 &amp;&amp; 1 -ne 0 ]];echo $?</code></pre>
<p>判断语句基本流程</p>
<pre><code>if [ condition1 ];then
command1
if [ condition2 ];then
command2
fi
 else
if [ condition3 ];then
command3
elif [ condition4 ];then
command4
else
command5
fi
fi</code></pre>
<h1 id="循环语句基本流程"><a href="#循环语句基本流程" class="headerlink" title="循环语句基本流程"></a>循环语句基本流程</h1><h2 id="for-语句循环"><a href="#for-语句循环" class="headerlink" title="for 语句循环"></a>for 语句循环</h2><p> ##<br>    for variable in {list}<br>            do<br>                command<br>                command<br>            done<br>    for variable in {list} ;do command command ;done</p>
<pre><code>for(( expr1;expr2;expr3 ))
do
command
command
…
done
for (( i=1;i&lt;=5;i++))
do
echo $i
done


expr1：定义变量并赋初值
expr2：决定是否进行循环（条件）
expr3：决定循环变量如何改变，决定循环什么时候退出</code></pre>
<h2 id="while-语句循环"><a href="#while-语句循环" class="headerlink" title="while 语句循环"></a>while 语句循环</h2><pre><code>while 表达式
    do
        command
    done

while  [ 1 -eq 1 ] 或者 (( 1 &gt; 2 ))
  do
 command
 ...
 done</code></pre>
<h2 id="until语句循环"><a href="#until语句循环" class="headerlink" title="until语句循环"></a>until语句循环</h2><pre><code>until expression   [ 1 -eq 1 ]  (( 1 &gt;= 1 ))
do
command
command
...
done</code></pre>
]]></content>
      <categories>
        <category>shell语句基础篇</category>
      </categories>
  </entry>
</search>
